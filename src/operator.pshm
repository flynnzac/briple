/* 
   SLOBIL is a Object Based Environment and Language
   Copyright 2021 Zach Flynn <zlflynn@gmail.com>

   This file is part of SLOBIL.

   SLOBIL is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   SLOBIL is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with SLOBIL (in COPYING file).  If not, see <https://www.gnu.org/licenses/>.
   
*/
/**
 * @file operator.c
 * @brief Functions that define the built-in operations of SLOBIL.
 */

`#include "slobil.h"'

`#include <errno.h>'


#FREE=`
`#ifdef GARBAGE
#undef free''`
free(#data~);
`#define free(x)
#endif
''@


#CHECK_ARGS=`check_length(&#a~, #length~+1, "#op~", obj->task->task);
if (is_error(-1, obj->task->task)) return #retcheck~;'@

#GETARG=`
data* arg#num~ = resolve(a.arg_array[#num~], obj);

if (#requireans~)
  {
    if (arg#num~ == NULL)
      {
        char* err_msg;
        err_msg = malloc(sizeof(char)*(strlen("<#op~> requires at least  arguments.")+digits(#num~)+1));
        sprintf(err_msg, "<#op~> requires at least %d arguments.", #num~);
        do_error(err_msg, obj->task->task);
        free(err_msg);
        return #retfail~;
      }
  }
if (arg#num~ != NULL && #checktype~ && (!(arg#num~->type & #type~)))
  {
    char* err_msg = malloc(sizeof(char)*(strlen("Argument  of <#op~> should be of type #type~.")+digits(#num~)+1));
    sprintf(err_msg, "Argument %d of <#op~> should be of type #type~.", #num~);
    do_error(err_msg, obj->task->task);
    free(err_msg);
    return #retfail~;
  }
'
@;

#requireans=true@
#checktype=true@

void
op_range (arg a, object* obj)
{
  #op=range@

  #a=a@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Integer@
  ##GETARG~$;

  #num=2@
  ##GETARG~$;

  mpz_t by;
  mpz_init(by);
  mpz_set_ui(by, 1);

  if (a.length >= 4)
    {
      #num=3@
      ##GETARG~$;
      mpz_set(by, *((mpz_t*) arg3->data));
    }

  char* prefix;
  if (a.length >= 5)
    {
      #num=4@
      #type=String@
      ##GETARG~$;
      prefix = slobil_u32_to_u8((uint32_t*) arg4->data,
                                u32_strlen((uint32_t*)
                                           arg4->data));
    }
  else
    {
      prefix = malloc(sizeof(char)*2);
      prefix[0] = 't';
      prefix[1] = '\0';
    }
      
  mpz_t* lb = (mpz_t*) arg1->data;
  mpz_t* ub = (mpz_t*) arg2->data;

  mpz_t elements;
  mpz_init(elements);
  mpz_sub(elements, *ub, *lb);
  mpz_cdiv_q(elements, elements, by);
  
  object* r_new = new_object(NULL,
                             new_hash_size(mpz_get_ui(elements)),
                             obj->task);

  mpz_t cur;
  mpz_init_set(cur, *lb);
  
  int i = 1;
  char* r = NULL;
  data* d_tmp;
  while (mpz_cmp(cur,*ub) <= 0)
    {
      r = custom_argument_name(i, prefix);
      assign_int(&d_tmp, cur);
      set(r_new, d_tmp, r, 0);
      free(r);
      i++;
      mpz_add(cur, cur, by);
    }

  d_tmp = new_data();
  d_tmp->type = Object;
  d_tmp->data = r_new;

  ret_ans(obj, d_tmp);

  free(prefix);
}

/**
 * Creates a list-like object with argument values at /t1, /t2, /t3, etc.
 *
 * @param a argument list containing the list operation as its first argument and an arbitrary
 * number of data elements following that.
 * @param obj the object to execute the operation in.
 */
void
op_list (arg a, object* obj)
{
  object* obj_new = new_object(NULL,
                               new_hash_size(a.length),
                               obj->task);
  data* d;
  data* d_new;
  int i = 1;
  char* r = NULL;

  for (i=1; i < a.length; i++)
    {
      r = argument_name(i);
      d_new = copy_data(resolve(a.arg_array[i], obj));
      set(obj_new, d_new, r, 0);
      free(r);
    }

  assign_object(&d, obj_new, false, obj->task);
  ret_ans(obj, d);
}

/**
 * Creates an object from pairs of slots and data values
 *
 * @param a argument containing the object operation as its first argument and an arbitrary number of slot-data pairs.
 * @param obj the object to execute the operation in.
 */
void
op_object (arg a, object* obj)
{
  if (a.length != 1)
    {
      #op=object@
      #length=2@
      ##CHECK_ARGS~$;
    }
  
  object* obj_new = new_object(NULL, new_hash_size(a.length / 2 + 1),
                                 obj->task);

  bool error = object_from_args(a, obj_new, 1, obj->task->task);
  if (error)
    {
      free_object(obj_new);
      return;
    }

  data* d;
  assign_object(&d, obj_new, false, obj->task);

  ret_ans(obj, d);
}

/**
 * Creates a new object, inheriting from an old object.
 *
 * @param a an argument list where the first element is this operation, the second argument is the
 * object to inherit from, and the following arguments (which are optional) are an alternating list
 * of slots and data values
 * @param obj the object to execute the operation in
 */
void
op_new(arg a, object* obj)
{
  #op=new@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Object@
  ##GETARG~$;

  object* new = new_object(NULL, SLOBIL_HASH_SIZE, obj->task);
  new->inherit = (object*) arg1->data;
  data* out;

  bool error = object_from_args(a, new, 2, obj->task->task);

  if (error)
    {
      free_object(new);
      return;
    }
  
  assign_object(&out, new, false, obj->task);
  ret_ans(obj, out);
}

/**
 * Unified arithmetic operation, not called from SLOBIL code, used for other
 * arithmetic operations.
 *
 * @param a argument list of Real or Integer objects
 * @param obj an object to execute the operation in
 * @param code an integer code to determine the arithmetic to do (1=add, 2=mul,
 * 3=sub, 4=div)
 */
void
op_arithmetic (arg a, object* obj, const int code)
{
  data* d;
  data_type result_type = Integer;
  mpz_t int_value;
  mpz_init_set_si(int_value, 0);
  double dbl_value = 0.0;

  #op=arithmetic@
  for (int i = 1; i < a.length; i++)
    {
      #num=i@
      #type=`(Real|Integer)'@
      ##GETARG~$;

      if (argi->type == Real && result_type == Integer)
        {
          dbl_value = mpz_get_d(int_value);
          result_type = Real;
        }

      if (result_type == Integer)
        {
          if (i == 1)
            mpz_set(int_value, *((mpz_t*) argi->data));
          else
            switch (code)
              {
              case 1:
                mpz_add(int_value, int_value, *((mpz_t*) argi->data));
                break;
              case 2:
                mpz_mul(int_value, int_value, *((mpz_t*) argi->data));
                break;
              case 3:
                mpz_sub(int_value, int_value, *((mpz_t*) argi->data));
                break;
              case 4:
                mpz_fdiv_q(int_value,
                           int_value, *((mpz_t*) argi->data));
                break;
              }
        }
      else
        {
          double val;
          if (argi->type == Integer)
            val = mpz_get_d(*((mpz_t*) argi->data));
          else
            val = *((double*) argi->data);
	    
          if (i == 1)
            dbl_value = val;
          else
            switch (code)
              {
              case 1:
                dbl_value += val;
                break;
              case 2:
                dbl_value *= val;
                break;
              case 3:
                dbl_value -= val;
                break;
              case 4:
                dbl_value /= val;
              }
        }
    }

  if (result_type == Integer)
    assign_int(&d, int_value);
  else
    assign_real(&d, dbl_value);
	      
  ret_ans(obj, d);
}  

/**
 * Adds its arguments and sets /ans slot to result
 *
 * @param a argument list of any number of either Real or Integer data values
 * @param obj the object to execute the operation in
 */
void
op_add (arg a, object* obj)
{
  #op=add@
  #length=2@
  ##CHECK_ARGS~$;

  op_arithmetic(a, obj, 1);
}

/**
 * Multiplies its arguments and sets /ans slot to result
 *
 * @param a argument list of any number of either Real or Integer data values
 * @param obj the object to execute the operation in
 */
void
op_mul (arg a, object* obj)
{
  #op=mul@
  #length=2@
  ##CHECK_ARGS~$;

  op_arithmetic(a, obj, 2);
}

/**
 * Subtracts its arguments and sets /ans slot to result
 *
 * @param a argument list of any number of either Real or Integer data values
 * @param obj the object to execute the operation in
 */
void
op_sub (arg a, object* obj)
{
  #op=sub@
  #length=2@
  ##CHECK_ARGS~$;

  op_arithmetic(a, obj, 3);
}
/**
 * Divides its arguments and sets /ans slot to result
 *
 * @param a argument list of any number of either Real or Integer data values
 * @param obj the object to execute the operation in
 */
void
op_div (arg a, object* obj)
{
  #op=div@
  #length=2@
  ##CHECK_ARGS~$;

  op_arithmetic(a, obj, 4);
}

/**
 * Executed if first element of statement is a slot.
 *
 * @param a argument list like for set but omitting the set operation
 * @param obj the object to set the slot in.
 */
void
auto_set (arg a, object* obj)
{
  #op=auto-set@
  #length=1@
  ##CHECK_ARGS~$;

  #num=0@
  #type=Slot@
  ##GETARG~$;

  #num=1@
  #checktype=false@
  ##GETARG~$;
  #checktype=true@

  object* to_set;
  if (a.length >= 3)
    {
      #num=2@
      #type=Object@
      ##GETARG~$;

      to_set = (object*) arg2->data;
    }
  else
    {
      to_set = obj;
    }

  char* name = ((slot*) arg0->data)->name;
  data* d = copy_data(arg1);
  set(to_set, d, name, 1);
}
  
/**
 * Sets a slot in an object to a given data value
 *
 * @param a argument list with first object the operation itself, the second a
 * slot to insert into, the third the value to insert, the fourth (optional) an
 * object to insert into.  If the last is omitted, insert into the current
 * object.
 * @param obj the object to execute the operation in.
 */
void
op_set (arg a, object* obj)
{
  #op=set@

  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Slot@
  ##GETARG~$;

  #num=2@
  #checktype=false@
  ##GETARG~$;
  #checktype=true@

  object* to_set;
  if (a.length >= 4)
    {
      #num=3@
      #type=Object@
      ##GETARG~$;
      
      to_set = (object*) arg3->data;
    }
  else
    {
      to_set = obj;
    }
  
  char* name = ((slot*) arg1->data)->name;
  data* d = copy_data(arg2);
  set(to_set, d, name, 1);


}

void
op_get (arg a, object* obj)
{
  #op=get@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Slot@
  ##GETARG~$;
  
  object* to_look;
  if (a.length == 2)
    {
      to_look = obj;
    }
  else
    {
      #num=2@
      #type=Object@
      ##GETARG~$;

      to_look = (object*) arg2->data;
    }

  data* ans = lookup(to_look, ((slot*) arg1->data),
                     a.length==2);
  if (ans != NULL)
    {
      ans = copy_data(ans);
      ret_ans(obj, ans);
    }
}

void
op_if (arg a, object* obj)
{
  #op=if@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Boolean@
  ##GETARG~$;

  #requireans=false@
  if (*((bool*) arg1->data))
    {
      if (a.length >= 3)
        {
          #num=2@
          #checktype=false@
          ##GETARG~$;
          #checktype=true@

          if (arg2 != NULL)
            {
              data* d = copy_data(arg2);
              ret_ans(obj, d);
            }
        }
    }
  else
    {
      if (a.length >= 4)
        {
          #num=3@
          #checktype=false@
          ##GETARG~$;
          #checktype=true@

          if (arg3 != NULL)
            {
              data* d = copy_data(arg3);
              ret_ans(obj,d);
            }
        }
    }
  #requireans=true@
}

void
op_sit (arg a, object* obj)
{
  for (int i=1; i < a.length; i++)
    {
      (void) resolve(a.arg_array[i], obj);
    }
  return;
}


void
op_move (arg a, object* obj)
{
  #op=move@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Slot@
  ##GETARG~$;

  #num=2@
  ##GETARG~$;

  mov(obj, (slot*) arg1->data,
      (slot*) arg2->data);
  
}

void
op_delete (arg a, object* obj)
{
  #op=delete@
  #length=1@
  ##CHECK_ARGS~$;
  
  #num=1@
  #type=Slot@
  ##GETARG~$;
  
  del(obj, ((slot*) arg1->data), 1, false);
}

void
op_exit (arg a, object* obj)
{
  int err = 0;
  if (a.length >= 2)
    {
      #op=exit@
      #num=1@
      #type=Integer@
      ##GETARG~$;

      err = mpz_get_si(*((mpz_t*) arg1->data));
    }
  is_exit(err+1, obj->task->task);
  is_error(1, obj->task->task);
}

void
op_exist (arg a, object* obj)
{
  #op=exist@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Slot@
  ##GETARG~$;

  object* to_use = obj;
  if (a.length >= 3)
    {
      #num=2@
      #type=Object@
      ##GETARG~$;

      to_use = (object*) arg2->data;
    }

  data* ret_obj = get(to_use, ((slot*) arg1->data), a.length < 3 ? 1 : 0);
  data* d;
  if (ret_obj == NULL)
    {
      assign_boolean(&d, false);
    }
  else
    {
      assign_boolean(&d, true);
    }

  ret_ans(obj,d);
}

void
op_answer (arg a, object* obj)
{
  #op=answer@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #checktype=false@
  ##GETARG~$;
  #checktype=true@

  data* d = copy_data(arg1);
  ret_ans(obj, d);
}

int
op_comparison (arg a, object* obj)
{
  #op=comparison@
  #length=2@
  #retcheck=-2@
  ##CHECK_ARGS~$;
  #retcheck=@

  #num=1@
  #type=`(Integer|Real)'@
  #retfail=-2@
  ##GETARG~$;

  #num=2@
  ##GETARG~$;

  #retfail=@

  if (arg1->type == Integer && arg2->type == Integer)
    {
      return mpz_cmp(*((mpz_t*) arg1->data), *((mpz_t*) arg2->data));
    }
  else
    {
      double dval1;
      double dval2;
      if (arg1->type == Integer)
        {
          dval1 = mpz_get_d(*((mpz_t*) arg1->data));
          dval2 = *((double*) arg2->data);
        }
      else if (arg2->type == Integer)
        {
          dval1 = *((double*) arg1->data);
          dval2 = mpz_get_d(*((mpz_t*) arg2->data));
        }
      else
        {
          dval1 = *((double*) arg1->data);
          dval2 = *((double*) arg2->data);
        }

      if (dval1 > dval2)
        {
          return 1;
        }
      else if (dval1 < dval2)
        {
          return -1;
        }
      else
        {
          return 0;
        }
            
    }
      
}

void
op_gt (arg a, object* obj)
{
  data* d = NULL;
  int is_gt = op_comparison(a, obj);

  if (is_error(-1, obj->task->task))
    return;

  if (is_gt==1)
    assign_boolean(&d, true);
  else
    assign_boolean(&d, false);

  ret_ans(obj,d);
}

void
op_lt (arg a, object* obj)
{
  data* d = NULL;
  int is_lt = op_comparison(a, obj);

  if (is_error(-1, obj->task->task))
    return;

  if (is_lt==-1)
    assign_boolean(&d, true);
  else
    assign_boolean(&d, false);

  ret_ans(obj,d);
}

void
op_eq (arg a, object* obj)
{
  data* d = NULL;
  int is_eq = op_comparison(a, obj);

  if (is_error(-1, obj->task->task))
    return;

  if (is_eq==0)
    assign_boolean(&d, true);
  else
    assign_boolean(&d, false);

  ret_ans(obj,d);
}

void
op_gt_eq (arg a, object* obj)
{
  data* d = NULL;
  int is_gteq = op_comparison(a, obj);

  if (is_error(-1, obj->task->task))
    return;

  if (is_gteq==1 || is_gteq==0)
    assign_boolean(&d, true);
  else
    assign_boolean(&d, false);

  ret_ans(obj,d);
}


void
op_lt_eq (arg a, object* obj)
{
  data* d = NULL;
  int is_lteq = op_comparison(a, obj);

  if (is_error(-1, obj->task->task))
    return;

  if (is_lteq==-1 || is_lteq==0)
    assign_boolean(&d, true);
  else
    assign_boolean(&d, false);

  ret_ans(obj,d);
}

void
op_print (arg a, object* obj)
{
  #op=print@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #checktype=false@
  ##GETARG~$;
  #checktype=true@
  print_settings settings = PRINT_NEWLINE;

  if (a.length >= 3)
    {
      #num=2@
      #requireans=false@
      #checktype=false@
      #type=Boolean@
      ##GETARG~$;
      #requireans=true@
      #checktype=true@


      if (arg2 != NULL && arg2->type == Boolean)
        {
          if (!*((bool*) arg2->data))
            settings = PRINT_PLAIN;
        }
    }
             
  print_data(arg1,settings);
}

void
op_length (arg a, object* obj)
{
  #op=length@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=String@
  ##GETARG~$;

  size_t len = u32_strlen((uint32_t*) arg1->data);

  mpz_t len_z;
  mpz_init_set_ui(len_z, len);
  data* d;
  assign_int(&d, len_z);

  ret_ans(obj, d);
  
}

void
op_combine (arg a, object* obj)
{
  #op=combine@
  #length=2@
  ##CHECK_ARGS~$;

  size_t sz = 0;
  data* args[a.length-1];
  for (int i = 1; i < a.length; i++)
    {
      #num=i@
      #type=String@
      ##GETARG~$;
      args[i-1] = argi;
      sz += u32_strlen((uint32_t*) argi->data);
    }
  uint32_t* result = malloc(sizeof(uint32_t)*(sz+1));

  u32_strcpy(result, (uint32_t*) args[0]->data);
  for (int i=2; i < a.length; i++)
    {
      u32_strcat(result, (uint32_t*) args[i-1]->data);
    }

  data* d = new_data();
  d->type = String;
  d->data = result;

  ret_ans(obj, d);

}

void
op_source (arg a, object* obj)
{
  #op=source@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=String@
  ##GETARG~$;

  
  char* file = slobil_u32_to_u8((uint32_t*) arg1->data,
                             u32_strlen((uint32_t*) arg1->data));

  FILE* f = fopen(file, "r");
  
  if (f == NULL)
    {
      char* msg = malloc(sizeof(char)*(strlen("File not found.")
                                       + strlen(file) +
                                       6));
      sprintf(msg, "File *%s* not found.", file);
      do_error(msg, obj->task->task);
      free(msg);
      return;
    }

  struct parser_state state = fresh_state(0);
  interact(f, &state, obj);
  free_state(&state);
  free(file);
  fclose(f);

}

void
op_do (arg a, object* obj)
{
  #op=do@
  #length=2@
  ##CHECK_ARGS~$;

  data* arg1 = resolve(a.arg_array[1], obj);
  data** arg_objects = malloc(sizeof(data*)*
                                 (a.length-2));
  for (int i = 0; i < (a.length - 2); i++)
    {
      arg_objects[i] = resolve(a.arg_array[i+2], obj);
    }

  if (arg1 == NULL)
    {
      do_error("<do> requires an argument.", obj->task->task);
      free(arg_objects);
      return;
    }

  for (int i = 0; i < (a.length-2); i++)
    {
      if (arg_objects[i] == NULL)
        {
          do_error("<do> requires more than one argument.",
                   obj->task->task);
          free(arg_objects);
          return;
        }
    }
  

  if (arg1->type != Operation)
    {
      do_error("First argument to <do> must be an operation.",
               obj->task->task);
      return;
    }

  for (int i = 0; i < (a.length - 2); i++)
    {
      if (arg_objects[i]->type != Object)
        {
          do_error("Arguments to <do> must be objects.",
                   obj->task->task);
          free(arg_objects);
          return;
        }
    }

  object** arg_obj = malloc(sizeof(object*)*(a.length-2));
  for (int i = 0; i < (a.length - 2); i++)
    {
      arg_obj[i] = (object*) arg_objects[i]->data;
    }
  object* ret_obj = new_object(NULL, SLOBIL_HASH_SIZE,
                               obj->task);
  data* d;
  arg a1;

  a1.length = 1 + a.length-2;

  a1.free_data = malloc(sizeof(int)*a1.length);
  for (int i = 0; i < a1.length; i++)
    a1.free_data[i] = 0;

  a1.arg_array = malloc(sizeof(data*)*a1.length);
  a1.arg_array[0] = arg1;
  for (int i = 1; i < a1.length; i++)
    a1.arg_array[i] = NULL;


  for  (int i = 0; i < arg_obj[0]->hash_size; i++)
    {
      content* c = arg_obj[0]->objects[i];
      if (c == NULL)
        continue;
      
      if (is_init_content(c))
        continue;

      c = tail(c);
      while (c != NULL)
        {
          bool in_all = true;
          for (int j = 0; j < (a.length-2); j++)
            {
              slot sl;
              sl.name = c->name;
              sl.key = c->key;
              d = get(arg_obj[j], &sl, 0);
              if (d==NULL)
                {
                  c = c->right;
                  in_all = false;
                  break;
                }
              else
                {
                  a1.arg_array[1+j] = d;
                }
            }

          if (!in_all)
            continue;

          compute(arg1, obj, a1);
          d = lookup(obj, &obj->task->task->slobil_slot_ans, 0);
          if (d != NULL)
            {
              d = copy_data(d);
              set(ret_obj, d, c->name, 1);
            }
          c = c->right;
        }
    }

  if (!is_error(-1, obj->task->task))
    {
      d = new_data();
      d->type = Object;
      d->data = ret_obj;
      ret_ans(obj, d);
    }
  
}

data*
slot_arithmetic (slot* rg, int diff, task_vars* task)
{
  char* cur_name = malloc(sizeof(char)*(strlen(rg->name)+1));
  strcpy(cur_name, rg->name);

  int i = strlen(cur_name)-1;
  int j;
  while (i >= 0 && isdigit((int) cur_name[i]))
    i--;

  if (i == (strlen(cur_name)-1))
    {
      i = 0;
    }
  
  i++;
  
  char* cur_num = malloc(sizeof(char)*(strlen(cur_name)-i + 1));
  for (j = i; j < strlen(cur_name); j++)
    {
      cur_num[j-i] = cur_name[j];
    }
  cur_num[strlen(cur_name)-i] = '\0';
  cur_name[i] = '\0';
  int num = atoi(cur_num)+diff;
  if (num < 1) num = 1;

  free(cur_num);

  char* new_name = malloc(sizeof(char)*(strlen(cur_name)+2));
  sprintf(new_name, "%s%d", cur_name, num);
  data* d = new_data();
  d->type = Slot;
  d->data = malloc(sizeof(slot));
  ((slot*) d->data)->name = new_name;
  ((slot*) d->data)->key = hash_str(new_name);
  free(cur_name);
  
  return d;
}
  

void
op_next (arg a, object* obj)
{
  #op=next@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Slot@
  ##GETARG~$;

  data* d = slot_arithmetic((slot*) arg1->data, 1,
                                obj->task->task);
  if (d != NULL)
    ret_ans(obj,d);
}

void
op_previous (arg a, object* obj)
{
  #op=previous@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Slot@
  ##GETARG~$;

  data* d = slot_arithmetic((slot*) arg1->data, -1,
                                obj->task->task);
  if (d != NULL)
    ret_ans(obj,d);
}


void
op_last (arg a, object* obj)
{
  #op=last@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Object@
  ##GETARG~$;

  #num=2@
  #type=Slot@
  ##GETARG~$;

  object* arg_obj = (object*) arg1->data;
  int i = 1;
  data* d;
  char* root = ((slot*) arg2->data)->name;

  slot sl;
  sl.name = vector_name(root, i);
  sl.key = hash_str(sl.name);

  while ((d = get(arg_obj, &sl, 0)) != NULL)
    {
      i++;
      free(sl.name);
      sl.name = vector_name(root, i);
      sl.key = hash_str(sl.name);
    }
  free(sl.name);

  sl.name = vector_name(root, i-1);

  d = new_data();
  d->type = Slot;
  d->data = malloc(sizeof(slot));
  ((slot*) d->data)->name = sl.name;
  ((slot*) d->data)->key = hash_str(sl.name);

  ret_ans(obj, d);
  
}

void
method_call (arg a, object* obj)
{
  #op=method-call@
  #length=1@
  ##CHECK_ARGS~$;

  #num=0@
  #type=Object@
  ##GETARG~$;

  #num=1@
  #type=Slot@
  ##GETARG~$;

  data* instr = get((object*) arg0->data,
                    ((slot*) arg1->data),
                    0);

  if (instr == NULL)
    {
      do_error("Slot not found in object.",
               obj->task->task);
      return;
    }

  if (!(instr->type & Instruction))
    {
      do_error("Method must be an instruction.",
               obj->task->task);
      return;
    }

  arg b = shift_arg_left(a);
  b.arg_array[0] = instr;

  object* tmp = ((object*) arg0->data)->up;
  ((object*) arg0->data)->up = obj;
  _op_call(b, (object*) arg0->data, obj, 0);

  ((object*) arg0->data)->up = tmp;
  
}

void
op_in (arg a, object* obj)
{
  #op=in@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Object@
  ##GETARG~$;

  #num=2@
  #type=Instruction@
  ##GETARG~$;

  ((object*) arg1->data)->up = obj;
  execute_0(arg2, (object*) arg1->data);
  ((object*) arg1->data)->up = NULL;
  
  data* ans = lookup((object*) arg1->data, &obj->task->task->slobil_slot_ans, 0);
  if (ans != NULL)
    {
      ans = copy_data(ans);
      ret_ans(obj, ans);
    }
}

void
op_while (arg a, object* obj)
{
  #op=while@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Instruction@
  ##GETARG~$;

  #num=2@
  ##GETARG~$;

  data* d;
  while (1)
    {
      execute_0(arg1, obj);
      
      if (is_error(-1, obj->task->task))
        break;
          
      d = get(obj, &obj->task->task->slobil_slot_ans, 0);

      if (d == NULL)
        {
          do_error("Instruction did not set *ans* to a value.",
                   obj->task->task);
          break;
        }

      if (d->type != Boolean)
        {
          do_error("First instruction should set *ans* to a Boolean.",
                   obj->task->task);
          break;
        }

      if (!(*(bool*) d->data))
        {
          break;
        }

      execute_0(arg2, obj);
      if (is_error(-1, obj->task->task))
        break;

    }

}

void
op_repeat (arg a, object* obj)
{
  #op=repeat@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Integer@
  ##GETARG~$;

  #num=2@
  #type=Instruction@
  ##GETARG~$;

  mpz_t i;
  mpz_init_set_si(i, 0);
  while (mpz_cmp(i, *((mpz_t*) arg1->data)) < 0)
    {
      execute_0(arg2, obj);
      if (is_error(-1, obj->task->task)) break;
      mpz_add_ui(i, i, 1);
    }
}

void
op_to_slot (arg a, object* obj)
{
  #op=to-slot@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=`(String|Integer)'@
  ##GETARG~$;

  data* d;

  if (arg1->type == String)
    {
      char* str = slobil_u32_to_u8((uint32_t*) arg1->data,
                                u32_strlen((uint32_t*) arg1->data));
      assign_slot(&d, str, hash_str(str));
      free(str);
    }
  else
    {
      int val = mpz_get_si(*((mpz_t*) arg1->data));
      char* name = argument_name(val);
      unsigned long hash_name = hash_str(name);
      assign_slot(&d, name, hash_name);
      free(name);
    }

  ret_ans(obj,d);

}


void
op_collapse (arg a, object* obj)
{
  #op=collapse@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Operation@
  ##GETARG~$;

  #num=2@
  #type=Object@
  ##GETARG~$;

  const char* prefix = "t";
  if (a.length >= 4)
    {
      #num=3@
      #type=Slot@
      ##GETARG~$;

      prefix = ((slot*) arg3->data)->name;
    }

  data* d;
  char* second_name;
  char* first_name;
  int i = 2;
  object* to_walk = (object*) arg2->data;
  to_walk->up = obj;

  first_name = vector_name(prefix, 1);
  second_name = vector_name(prefix, i);
  
  slot first_slot;
  slot second_slot;
  
  first_slot.name = first_name;
  first_slot.key = hash_str(first_name);

  second_slot.name = second_name;
  second_slot.key = hash_str(second_name);

  object* r = new_object(to_walk, SLOBIL_HASH_SIZE, obj->task);

  arg a1;
  a1.length = 3;
  a1.free_data = malloc(sizeof(int)*a1.length);
  a1.arg_array = malloc(sizeof(data*)*a1.length);
  for (int j = 0; j < a1.length; j++)
    {
      a1.free_data[j] = 0;
    }

  a1.arg_array[0] = arg1;
  
  data* d1;
  data* d2;

  int is_first = 1;
  
  while ((d = lookup(to_walk, &second_slot, 0)) != NULL)
    {

      if (is_first)
        d1 = lookup(to_walk, &first_slot, 0);
      
      d2 = lookup(to_walk, &second_slot, 0);

      a1.arg_array[1] = d1;
      a1.arg_array[2] = d2;
        
      compute(arg1, r, a1);
      d1 = lookup(r, &obj->task->task->slobil_slot_ans, 0);

      if (d1 == NULL)
        {
          do_error("Operation did not set /ans slot.",
                   obj->task->task);
          break;
        }
      
      if (is_first)
        {
          free(first_name);
          first_slot = obj->task->task->slobil_slot_ans;
          is_first = 0;
        }
      i++;
      free(second_name);
      second_name = vector_name(prefix, i);
      second_slot.name = second_name;
      second_slot.key = hash_str(second_name);
    }
  d = lookup(r, &obj->task->task->slobil_slot_ans, 0);
  if (d != NULL)
    {
      ret_ans(obj, copy_data(d));
    }

  free_object(r);
  free(second_name);
  free_arg(&a1);
}

void
op_string_eq (arg a, object* obj)
{
  #op=string-eq@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=String@
  ##GETARG~$;

  #num=2@
  #type=String@
  ##GETARG~$;

  uint32_t* str1 = (uint32_t*) arg1->data;
  uint32_t* str2 = (uint32_t*) arg2->data;
  data* d;
  if (u32_strcmp(str1,str2) == 0)
    {
      assign_boolean(&d, true);
    }
  else
    {
      assign_boolean(&d, false);
    }

  ret_ans(obj, d);
}

void
op_char_eq (arg a, object* obj)
{
  #op=char-eq@
  #length=3@
  ##CHECK_ARGS~$;

  #num=1@
  #type=String@
  ##GETARG~$;

  #num=2@
  #type=Integer@
  ##GETARG~$;

  #num=3@
  #type=String@
  ##GETARG~$;

  uint32_t* str = (uint32_t*) arg1->data;
  uint32_t* str_cmp = (uint32_t*) arg3->data;

  mpz_t start;
  mpz_init_set(start, *((mpz_t*) arg2->data));

  size_t length = u32_strlen(str);

  slobil_location(start, length);

  if (mpz_cmp_ui(start,length)>0 || (mpz_cmp_si(start,0) <= 0))
    {
      do_error("Index out of range.", obj->task->task);
      return;
    }

  uint32_t* first = str+mpz_get_ui(start)-1;

  bool res = first[0]==str_cmp[0];
  
  data* d = NULL;
  assign_boolean(&d, res);

  ret_ans(obj,d);

}

void
op_string_lt (arg a, object* obj)
{
  #op=string-lt@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=String@
  ##GETARG~$;

  #num=2@
  #type=String@
  ##GETARG~$;

  uint32_t* str1 = (uint32_t*) arg1->data;
  uint32_t* str2 = (uint32_t*) arg2->data;
  data* d;
  if (u32_strcmp(str1,str2) < 0)
    {
      assign_boolean(&d, true);
    }
  else
    {
      assign_boolean(&d, false);
    }

  ret_ans(obj, d);
}

void
op_string_gt (arg a, object* obj)
{
  #op=string-gt@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=String@
  ##GETARG~$;

  #num=2@
  #type=String@
  ##GETARG~$;

  uint32_t* str1 = (uint32_t*) arg1->data;
  uint32_t* str2 = (uint32_t*) arg2->data;
  data* d;
  if (u32_strcmp(str1,str2) > 0)
    {
      assign_boolean(&d, true);
    }
  else
    {
      assign_boolean(&d, false);
    }

  ret_ans(obj, d);
}


void
op_slot_eq (arg a, object* obj)
{
  #op=slot-eq@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Slot@
  ##GETARG~$;

  #num=2@
  #type=Slot@
  ##GETARG~$;
      
  data* d;

  if (((slot*) arg1->data)->key == ((slot*) arg2->data)->key)
    assign_boolean(&d,true);
  else
    assign_boolean(&d,false);

  ret_ans(obj,d);
}


void
op_save (arg a, object* obj)
{
  #op=save@  
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=String@
  ##GETARG~$;

  char* file = slobil_u32_to_u8((uint32_t*) arg1->data,
                             u32_strlen((uint32_t*) arg1->data));
             
  save_outer(obj, file);

  free(file);

}

void
op_load (arg a, object* obj)
{
  #op=load@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=String@
  ##GETARG~$;

  char* fname = slobil_u32_to_u8((uint32_t*) arg1->data,
                              u32_strlen((uint32_t*) arg1->data));
  
  gzFile f = gzopen(fname, "r");
  if (f == NULL)
    {
      do_error("File cannot be opened.",
               obj->task->task);
      return;
    }
  if (a.length >= 3)
    {
      #num=2@
      #type=Object@
      ##GETARG~$;

      read_outer(f, (object*) arg2->data);
    }
  else
    {
      read_outer(f, obj);
    }
  gzclose(f);

  free(fname);
}

void
op_to_string (arg a, object* obj)
{
  #op=to-string@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=`(Integer | Real | Slot)'@
  ##GETARG~$;

  char* result;
  if (arg1->type == Integer)
    {
      result = mpz_get_str(NULL, 10, *((mpz_t*) arg1->data));
    }
  else if (arg1->type == Real)
    {
      data* arg2 = NULL;
      if (a.length >= 3)
        {
          arg2 = resolve(a.arg_array[2], obj);
        }
      
      int prec = 6;
      if (arg2 != NULL && arg2->type != Integer)
        {
          do_error("The second argument to *to-string* should be an integer.",
                   obj->task->task);
          return;
        }
      if (arg2 != NULL)
        {
          prec = *((int*) arg2->data);
          if (prec < 0)
            {
              do_error("The second argument to *to-string* must be non-negative.",
                       obj->task->task);
              return;
            }
        }
      int n_digits;
      if (prec == 0)
        {
          n_digits = 1;
        }
      else
        {
          n_digits = floor(log10(prec)) + 1;
        }
      
      char* fmt = malloc(sizeof(char)*(strlen("%.f") + n_digits + 1));
      sprintf(fmt, "%%.%df", prec);

      int int_part = floor(*((double*) arg1->data));

      int int_size;
      if (int_part == 0)
        {
          int_size = 1;
        }
      else
        {
          int_size = floor(log10(int_part)) + 1;
        }
      result = malloc(sizeof(char)*(int_size+1+prec+1));
      sprintf(result, fmt, *((double*) arg1->data));
      free(fmt);
    }
  else
    {
      char* slot_name = ((slot*) arg1->data)->name;
      result = malloc(sizeof(char)*(strlen(slot_name)+1));
      strcpy(result, slot_name);
    }

  uint32_t* res32 = slobil_u8_to_u32(result, strlen(result));
  data* d;
  assign_str(&d, res32, 0);
  ret_ans(obj, d);
  
  free(res32);
  
}

void
op_to_number (arg a, object* obj)
{
  #op=to-number@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=`(String|Slot)'@
  ##GETARG~$;

  if (arg1->type == String)
    {
      uint32_t* value = (uint32_t*) arg1->data;
      char* u8_value = slobil_u32_to_u8(value, u32_strlen(value));
      data* d;
      if (is_integer(u8_value))
        {
          mpz_t result;
          mpz_init_set_str(result, u8_value, 10);
          assign_int(&d, result);
          mpz_clear(result);
          ret_ans(obj, d);
        }
      else if (is_real(u8_value) && (strcmp(u8_value, ".") != 0))
        {
          double result = atof(u8_value);
          assign_real(&d, result);
          ret_ans(obj, d);
        }
      else
        {
          do_error("String not a number.", obj->task->task);
        }

      free(u8_value);
    }
  else
    {
      char* name = ((slot*) arg1->data)->name;
      int i = strlen(name);
      for (i = (strlen(name)-1); i >= 0; i--)
        {
          if (!isdigit(name[i]))
            break;
        }

      if (i >= (strlen(name)-1))
        {
          do_error("Slot does not end in a number.",
                   obj->task->task);
          return;
        }

      name += i + 1;

      data* d;
      mpz_t m;
      mpz_init_set_str(m, name, 10);
      assign_int(&d, m);
      mpz_clear(m);
      ret_ans(obj,d);
    }
  
}

void
op_to_real (arg a, object* obj)
{
  #op=to-real@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=`(Integer|Real|String)'@
  ##GETARG~$;

  data* d;
  if (arg1->type == Integer)
    assign_real(&d, mpz_get_d(*((mpz_t*) arg1->data)));
  else if (arg1->type == Real)
    d = copy_data(arg1);
  else
    {
      char* u8value = slobil_u32_to_u8((uint32_t*) arg1->data,
                                    u32_strlen((uint32_t*) arg1->data));

      double result = atof(u8value);
      assign_real(&d, result);

      free(u8value);

    }
    
  ret_ans(obj,d);
  
}

void
op_output_code (arg a, object* obj)
{
  #op=output-code@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=String@
  ##GETARG~$;

  if (obj->task->task->source_code != NULL)
    {
      char* fname = slobil_u32_to_u8((uint32_t*) arg1->data,
                                  u32_strlen((uint32_t*) arg1->data));
      FILE* f = fopen(fname, "w");
      fwrite(obj->task->task->source_code, sizeof(char),
             strlen(obj->task->task->source_code), f);
      fclose(f);
      free(fname);
      
    }
  else
    {
      do_error("No source saved yet.", obj->task->task);
      return;
    }
}

void
op_clear_code (arg a, object* obj)
{
  if (obj->task->task->source_code != NULL)
    free(obj->task->task->source_code);

  obj->task->task->source_code = NULL;
}

void
op_error (arg a, object* obj)
{
  #op=error@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=String@
  ##GETARG~$;

  char* err_msg = slobil_u32_to_u8((uint32_t*) arg1->data,
                                u32_strlen((uint32_t*) arg1->data));
  
  do_error(err_msg, obj->task->task);
  free(err_msg);
  
  if (a.length >= 3)
    {
      #num=2@
      #type=Integer@
      #requireans=false@
      ##GETARG~$;
      #requireans=true@
      if (arg2 != NULL)
        {
          is_error(mpz_get_si(*((mpz_t*) arg2->data)), obj->task->task);
        }
    }
}

void
op_is_type (arg a, object* obj, const data_type type)
{
  #op=is-Type@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #checktype=false@
  ##GETARG~$;
  #checktype=true@
  data* d;
  if (arg1->type == type)
    {
      assign_boolean(&d, true);
    }
  else
    {
      assign_boolean(&d, false);
    }

  ret_ans(obj,d);
}

void
op_is_integer (arg a, object* obj)
{
  op_is_type(a, obj, Integer);
}

void
op_is_real (arg a, object* obj)
{
  op_is_type(a, obj, Real);
}

void
op_is_string (arg a, object* obj)
{
  op_is_type(a, obj, String);
}

void
op_is_slot (arg a, object* obj)
{
  op_is_type(a, obj, Slot);
}

void
op_is_object (arg a, object* obj)
{
  op_is_type(a, obj, Object);
}

void
op_is_instruction (arg a, object* obj)
{
  op_is_type(a, obj, Instruction);
}

void
op_is_file (arg a, object* obj)
{
  op_is_type(a, obj, File);
}

void
op_is_nothing (arg a, object* obj)
{
  op_is_type(a, obj, Nothing);
}

void
op_is_boolean (arg a, object* obj)
{
  op_is_type(a, obj, Boolean);
}

void
op_is_operation (arg a, object* obj)
{
  op_is_type(a, obj, Operation);
}


void
op_open_file (arg a, object* obj)
{
  #op=open-file@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=String@
  ##GETARG~$;

  FILE* f;
  char* fname = slobil_u32_to_u8((uint32_t*) arg1->data,
                              u32_strlen((uint32_t*) arg1->data));
  if (a.length >= 3)
    {
      #num=2@
      #type=String@
      ##GETARG~$;

      char* mode = slobil_u32_to_u8((uint32_t*) arg2->data,
                                 u32_strlen((uint32_t*) arg2->data));

      f = fopen(fname, mode);
      free(mode);
    }
  else
    {
      f = fopen(fname, "r+");
    }

  free(fname);

  if (f == NULL)
    {
      do_error("File did not open.  Possibly, it does not exist.",
               obj->task->task);
      return;
    }

  data* d;

  assign_file(&d,f);
  ret_ans(obj,d);

}

void
op_read (arg a, object* obj)
{
  #op=read@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=File@
  ##GETARG~$;

  int c = fgetc((FILE*) arg1->data);
  data* d;

  if (c == EOF || c == '\0')
    {
      assign_nothing(&d);
    }
  else
    {
      mpz_t m;
      mpz_init_set_si(m, c);
      assign_int(&d, m);
    }
  ret_ans(obj, d);
}

void
op_read_char (arg a, object* obj)
{
  #op=read-char@  
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=File@
  ##GETARG~$;

  unsigned char* c = malloc(sizeof(char)*5);
  c[0] = fgetc((FILE*) arg1->data);
  int nbytes = 1;
  while (c[0] & (((unsigned char) 128)>>(nbytes-1)))
    {
      printf("%d: %d\n", nbytes, (((unsigned char) 128)>>(nbytes-1)));
      nbytes++;
    }
  nbytes = nbytes > 1 ? (nbytes-1) : 1;

  for (int i = 1; i < nbytes; i++)
    {
      c[i] = fgetc((FILE*) arg1->data);
    }
  
  data* d;
  if (c[0] == EOF || c[0] == '\0')
    {
      assign_nothing(&d);
    }
  else
    {
      c[nbytes] = '\0';
      uint32_t* c32 = slobil_u8_to_u32(c, strlen(c));
      assign_str(&d, c32, 0);
    }
  ret_ans(obj,d);
}

void
op_close (arg a, object* obj)
{
  #op=close@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Slot@
  ##GETARG~$;

  data* f = lookup(obj, ((slot*) arg1->data), 0);

  if (f == NULL)
    {
      do_error("Slot does not exist.",
               obj->task->task);
      return;
    }

  if (f->type != File)
    {
      do_error("Slot does not contain a file.",
               obj->task->task);
      return;
    }

  if (f->data != NULL)
    {
      fclose((FILE*) f->data);
    }

  del(obj, ((slot*) arg1->data), 1, false);
  
}

void
op_or (arg a, object* obj)
{
  #op=or@
  #length=2@
  ##CHECK_ARGS~$;

  bool check = false;

  for (int i=1; i < a.length; i++)
    {
      #num=i@
      #type=Boolean@
      ##GETARG~$;
      if (*((bool*) argi->data))
        {
          check = true;
          break;
        }
    }

  data* d;
  assign_boolean(&d, check);

  ret_ans(obj,d);
}

void
op_and (arg a, object* obj)
{
  #op=and@
  #length=2@
  ##CHECK_ARGS~$;

  bool check = true;
  for (int i=1; i < a.length; i++)
    {
      #num=i@
      #type=Boolean@
      ##GETARG~$;
      if (!(*((bool*) argi->data)))
        {
          check = false;
          break;
        }
    }

  data* d;
  assign_boolean(&d, check);

  ret_ans(obj,d);
}

void
op_not (arg a, object* obj)
{
  #op=not@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Boolean@
  ##GETARG~$;

  data* d;
  if (*((bool*) arg1->data))
    {
      assign_boolean(&d, false);
    }
  else
    {
      assign_boolean(&d, true);
    }

  ret_ans(obj,d);
}

void
op_read_line (arg a, object* obj)
{
  #op=read-line@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=File@
  ##GETARG~$;

  char* line  = NULL;
  size_t len = 0;
  ssize_t ret = getdelim(&line, &len, '\n', (FILE*) arg1->data);

  data* d;
  if (ret >= 0)
    {
      if (!feof((FILE*) arg1->data))
        line[strlen(line)-1] = '\0';

      uint32_t* u32_line = slobil_u8_to_u32(line, strlen(line));
      assign_str(&d, u32_line, 0);

			#data=line@ 
      ##FREE~$;
      ret_ans(obj,d);
    }
  else
    {
      assign_nothing(&d);
      ret_ans(obj,d);

      #data=line@ 
      ##FREE~$;

    }
}

void
op_write_string (arg a, object* obj)
{
  #op=write-string@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=String@
  ##GETARG~$;

  #num=2@
  #type=File@
  ##GETARG~$;

  char* text = slobil_u32_to_u8((uint32_t*) arg1->data,
                             u32_strlen((uint32_t*) arg1->data));

  fwrite(text, sizeof(char), strlen(text), (FILE*) arg2->data);

  free(text);

}

void
op_write (arg a, object* obj)
{
  #op=write@
  #length=2@

  #num=1@
  #type=Integer@
  ##GETARG~$;

  #num=2@
  #type=File@
  ##GETARG~$;

  int i = mpz_get_ui(*((mpz_t*) arg1->data));
  if ((i >= 255) || (i < 0))
    {
      do_error("Value should be in range [0,255].",
               obj->task->task);
      return;
    }
  else
    {
      char c = (char) i;
      fwrite(&c, sizeof(char), 1, (FILE*) arg2->data);
    }
}

void
op_input (arg a, object* obj)
{
  #length=1@
  ##CHECK_ARGS~$;

  #op=input@
  #num=1@
  #type=Slot@
  ##GETARG~$;

  char* input = readline("");
  data* d;

  uint32_t* str = slobil_u8_to_u32(input, strlen(input));
                                
  assign_str(&d, str, 0);
  
  set(obj, d, ((slot*) arg1->data)->name, 1);

}

void
op_shell (arg a, object* obj)
{

  #op=shell@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=String@
  ##GETARG~$;

  char* cmd = slobil_u32_to_u8((uint32_t*) arg1->data,
                            u32_strlen((uint32_t*) arg1->data));
  FILE* f = popen(cmd, "r");

  uint32_t* raw;
  
  if (f == NULL)
    {
      do_error("Command failed.",
               obj->task->task);
      return;
    }

  char buffer[1024];
  data* d = NULL;
  while (fgets(buffer, sizeof(buffer)-1, f) != NULL)
    {
      if (d == NULL)
        {
          raw = slobil_u8_to_u32(buffer, strlen(buffer));
          assign_str(&d, raw, 0);
        }
      else
        {
          raw = slobil_u8_to_u32(buffer, strlen(buffer));
          d->data = realloc(d->data, sizeof(uint32_t)*(u32_strlen((uint32_t*) d->data)+u32_strlen(raw)+1));
          u32_strcat((uint32_t*) d->data, raw);
          free(raw);
        }
    }

  pclose(f);

  free(cmd);

  ret_ans(obj,d);
  
  
}

void
op_link (arg a, object* obj)
{
  #op=link@
  #length=3@
  ##CHECK_ARGS~$;

  #num=1@
  #type=String@
  ##GETARG~$;

  #num=2@
  ##GETARG~$;

  #num=3@
  ##GETARG~$;

  char* file = slobil_u32_to_u8((uint32_t*) arg1->data,
                             u32_strlen((uint32_t*) arg1->data));
  
  void* lib = dlopen(file, RTLD_LAZY);

  if (lib == NULL)
    {
      printf("`%'s\n", dlerror());
      do_error("Library failed to open.", obj->task->task);
      return;
    }

  char* op_name = slobil_u32_to_u8((uint32_t*) arg2->data,
                                u32_strlen((uint32_t*) arg2->data));
  
  operation new_op = dlsym(lib, op_name);
  if (new_op == NULL)
    {
      do_error("Error loading function.", obj->task->task);
      dlclose(lib);
      return;
    }

  char* slobil_op_name = slobil_u32_to_u8((uint32_t*) arg3->data,
                                    u32_strlen((uint32_t*) arg3->data));
  data* d;
  assign_op(&d, new_op, NULL, NULL, 0);
  set(obj, d, slobil_op_name, 1);

  if (obj->task->task->slobil_ll == NULL)
    {
      obj->task->task->slobil_ll = malloc(sizeof(void*));
    }
  else
    {
      obj->task->task->slobil_ll = realloc(obj->task->task->slobil_ll,
                                    sizeof(void*)*(obj->task->task->slobil_ll_cnt+1));
    }
  obj->task->task->slobil_ll[obj->task->task->slobil_ll_cnt] = lib;
  obj->task->task->slobil_ll_cnt++;

  free(slobil_op_name);
  free(op_name);
  free(file);
}

void
op_match (arg a, object* obj)
{
  #op=match@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=String@
  ##GETARG~$;

  #num=2@
  ##GETARG~$;

  char* str1 = slobil_u32_to_u8((uint32_t*) arg1->data,
                             u32_strlen((uint32_t*) arg1->data));

  char* str2 = slobil_u32_to_u8((uint32_t*) arg2->data,
                             u32_strlen((uint32_t*) arg2->data));
  

  int max_matches = 0;
  if (a.length >= 4)
    {
      #num=3@
      #type=Integer@
      ##GETARG~$;
      max_matches = mpz_get_ui(*((mpz_t*) arg3->data));
    }

  regex_t regex;
  int error = regcomp(&regex, str1, REG_EXTENDED);
  if (error)
    {
      do_error("Error compiling objular expression.", obj->task->task);
      return;
    }

  size_t n_groups = 10*(regex.re_nsub+1);
  regmatch_t* matches;


  data* d;
  assign_object(&d, NULL, true, obj->task);
  int i;
  int j;
  char* to_add;
  char* name;
  data* d_str;
  data* d_obj;
  int n_matches = 0;
  char* cursor = str2;
  size_t offset;
  while (max_matches <= 0 || n_matches < max_matches)
    {
      matches = malloc(sizeof(regmatch_t)*n_groups);
      error = regexec(&regex, cursor, n_groups, matches, 0);
      if (!error)
        {
          assign_object(&d_obj, NULL, true, obj->task);
          offset = 0;
          for (i=0; i < n_groups; i++)
            {
              if (matches[i].rm_so < 0)
                {
                  break;
                }
              else
                {
                  if (i==0) offset = matches[0].rm_eo;

                  to_add = malloc(sizeof(char)*(matches[i].rm_eo-
                                                matches[i].rm_so+2));
                  for (j=matches[i].rm_so; j < matches[i].rm_eo; j++)
                    {
                      to_add[j-matches[i].rm_so] = cursor[j];
                    }
                  to_add[j-matches[i].rm_so] = '\0';

                  uint32_t* u32_add = slobil_u8_to_u32(to_add,
                                                    strlen(to_add));
                  
                  assign_str(&d_str, u32_add, 0);

                  name = argument_name(i);
                  set((object*) d_obj->data, d_str, name, 1);
                  free(name);
                }
            }
          n_matches++;
          name = argument_name(n_matches);
          set((object*) d->data, d_obj, name, 1);
          free(name);

          free(matches);
          cursor += offset;
        }
      else
        {
          free(matches);
          break;
        }
    }

  free(str1);
  free(str2);

  ret_ans(obj, d);
  
}

void
op_replace (arg a, object* obj)
{
  #op=replace@
  #length=3@
  ##CHECK_ARGS~$;

  #type=String@
  #num=1@
  ##GETARG~$;

  #num=2@
  ##GETARG~$;

  #num=3@
  ##GETARG~$;

  char* str1 = slobil_u32_to_u8((uint32_t*) arg1->data,
                             u32_strlen((uint32_t*) arg1->data));

  char* str2 = slobil_u32_to_u8((uint32_t*) arg2->data,
                             u32_strlen((uint32_t*) arg2->data));

  char* str3 = slobil_u32_to_u8((uint32_t*) arg3->data,
                             u32_strlen((uint32_t*) arg3->data));

  int max_replace = 0;
  if (a.length >= 5)
    {
      #num=4@
      #type=Integer@
      ##GETARG~$;
      max_replace = mpz_get_ui(*((mpz_t*) arg4->data));
    }

  regex_t regex;
  int error = regcomp(&regex, str1, REG_EXTENDED);
  if (error)
    {
      do_error("Error compiling regular expression.",
               obj->task->task);
      return;
    }

  regmatch_t* matches = malloc(sizeof(regmatch_t));
  data* d;
  assign_object(&d, NULL, true, obj->task);


  char* cursor = str3;

  /* contains pairs of integers denoting ranges to copy from arg3->data.  After each pair insert string. */
  size_t offset;
  size_t n_ranges = 1;

  while (max_replace <= 0 || n_ranges <= max_replace)
    {
      error = regexec(&regex, cursor, 1, &matches[n_ranges-1], 0);
      if (!error)
        {
          offset = 0;
          if (matches[n_ranges].rm_so < 0)
            {
              break;
            }
          else
            {
              offset = matches[n_ranges-1].rm_eo;
              n_ranges++;
              matches = realloc(matches, n_ranges*sizeof(regmatch_t));
              cursor += offset;
            }
        }
      else
        {
          break;
        }
    }
  n_ranges--;

  size_t last = 0;
  int i;
  int j;
  char* final;
  cursor = str3;
  /* calculate size of final string */
  size_t final_sz = 0;
  size_t last_range = 0;
  for (i = 0; i < n_ranges; i++)
    {
      final_sz += matches[i].rm_so;
      final_sz += strlen(str2);
      last_range += matches[i].rm_eo;
    }
  final_sz += strlen(str3) - last_range;

  final = malloc(sizeof(char)*(final_sz+1));
  for (i = 0; i < n_ranges; i++)
    {
      for (j = 0; j < matches[i].rm_so; j++)
        {
          final[last+j] = cursor[j];
        }

      last += matches[i].rm_so;

      for (j = 0; j < strlen(str2); j++)
        {
          final[last+j] = str2[j];
        }

      last += strlen(str2);
      
      cursor += matches[i].rm_eo;
    }

  for (j = 0; j < (final_sz-last); j++)
    {
      final[last+j] = cursor[j];
    }
  final[final_sz] = '\0';

  uint32_t* u32_final = slobil_u8_to_u32(final,
                                      strlen(final));
  
  assign_str(&d, u32_final, 0);
  ret_ans(obj,d);

  /* free(str1); */
  /* free(str2); */
  /* free(str3); */
  free(matches);

}

void
op_log (arg a, object* obj)
{
  #op=log@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=`(Integer|Real)'@
  ##GETARG~$;
  
  data* d;
  if (arg1->type == Integer)
    {
      assign_real(&d, log(mpz_get_d((*((mpz_t*) arg1->data)))));
    }
  else
    {
      assign_real(&d, log(*((double*) arg1->data)));
    }

  ret_ans(obj,d);
}


void
op_exp (arg a, object* obj)
{
  #op=exp@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=`(Integer|Real)'@
  ##GETARG~$;

  data* d;
  if (arg1->type == Integer)
    {
      assign_real(&d, exp(mpz_get_d(*((mpz_t*) arg1->data))));
    }
  else
    {
      assign_real(&d, exp(*((double*) arg1->data)));
    }

  ret_ans(obj,d);
}

void
op_power (arg a, object* obj)
{
  #op=power@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=`(Integer|Real)'@
  ##GETARG~$;

  #num=2@
  ##GETARG~$;

  double base;
  double power;
  data* d;
  if (arg1->type == Integer)
    {
      base = mpz_get_d(*((mpz_t*) arg1->data));
    }
  else
    {
      base = *((double*) arg1->data);
    }

  if (arg2->type == Integer)
    {
      power = mpz_get_d(*((mpz_t*) arg2->data));
    }
  else
    {
      power = *((double*) arg2->data);
    }

  assign_real(&d, pow(base,power));

  ret_ans(obj,d);
}

void
op_change_dir (arg a, object* obj)
{
  #op=change-dir@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=String@
  ##GETARG~$;

  char* dir = slobil_u32_to_u8((uint32_t*) arg1->data,
                            u32_strlen((uint32_t*) arg1->data));

  int error = chdir(dir);

  free(dir);
  
  if (error)
    {
      do_error("Could not change directory.", obj->task->task);
      return;
    }

}


void
op_import (arg a, object* obj)
{
  #op=import@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Object@
  ##GETARG~$;

  object* r1 = (object*) arg1->data;

  for (int i = 0; i < r1->hash_size; i++)
    {
      content* c = r1->objects[i];

      if (c == NULL)
        continue;

      if (is_init_content(c))
        continue;
      
      c = tail(c);
  
      data* d = NULL;
      while (c != NULL)
        {
          d = c->value;
          if (d != NULL)
            {
              d = copy_data(d);
              set(obj, d, (char*) c->name, 1);
            }
          c = c->right;
        }
    }
}


void
op_current_dir (arg a, object* obj)
{
  char* dir = get_current_dir_name();
  if (dir == NULL)
    {
      do_error("Error getting current directory.", obj->task->task);
      return;
    }
  data* d;
  uint32_t* u32dir = slobil_u8_to_u32(dir, strlen(dir));
  assign_str(&d, u32dir, 0);

  #data=dir@ 
  ##FREE~$; 

  ret_ans(obj,d);
}

void
op_substring (arg a, object* obj)
{
  #op=substring@
  #length=3@
  ##CHECK_ARGS~$;

  #num=1@
  #type=String@
  ##GETARG~$;

  #num=2@
  #type=Integer@
  ##GETARG~$;

  #num=3@
  ##GETARG~$;

  uint32_t* str = (uint32_t*) arg1->data;
  mpz_t start;
  mpz_t end;

  mpz_init_set(start, *((mpz_t*) arg2->data));
  mpz_init_set(end, *((mpz_t*) arg3->data));
  

  size_t length = u32_strlen(str);

  slobil_location(start, length);
  slobil_location(end, length);

  if (mpz_cmp_ui(start,length)>0 || (mpz_cmp_si(start,0) <= 0))
    {
      do_error("Index out of range.", obj->task->task);
      return;
    }


  if ((mpz_cmp_ui(end,length)>0) || (mpz_cmp_si(end,0) <= 0))
    {
      do_error("Index out of range.", obj->task->task);
      return;
    }

  if (mpz_cmp(start,end) > 0)
    {
      do_error("The starting position of the substring is greater than the ending position.", obj->task->task);
      return;
    }

  uint32_t* first = str+mpz_get_ui(start)-1;
  mpz_t diff;
  mpz_init(diff);
  mpz_sub(diff, end, start);
  size_t sz = mpz_get_ui(diff);

  uint32_t* result = malloc(sizeof(uint32_t)*(sz + 2));

  for (int i=0; i < (sz+1); i++)
    {
      result[i] = first[i];
    }

  result[sz+1] = (uint32_t) 0;

  data* d;
  assign_str(&d, result, 0);
  ret_ans(obj, d);

  mpz_clear(start);
  mpz_clear(end);
  mpz_clear(diff);
  
}

void
op_up (arg a, object* obj)
{
  #op=up@
  #length=1@
  ##CHECK_ARGS~$;

  if (obj->up == NULL)
    {
      do_error("Cannot use *up* instruction at top-level object.",
               obj->task->task);
      return;
    }

  arg a1 = gen_arg(a.length-1,0);
  for (int i=1; i < a.length; i++)
    {
      a1.arg_array[i-1] = resolve(a.arg_array[i], obj);
    }

  compute(a1.arg_array[0], obj->up, a1);

  data* d = lookup(obj->up, &obj->task->task->slobil_slot_ans, 0);
  if (d != NULL)
    {
      d = copy_data(d);
      ret_ans(obj, d);
    }

  free_arg(&a1);


}

void
op_code (arg a, object* obj)
{
  #op=code@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Instruction@
  ##GETARG~$;

  data* d;
  char* code = ((instruction*) arg1->data)->code;
  uint32_t* u32code = slobil_u8_to_u32(code, strlen(code));
  
  assign_str(&d, u32code, 0);

  ret_ans(obj, d);
      
}

void
op_is_error (arg a, object* obj)
{
  #op=is-error@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Instruction@
  ##GETARG~$;

  int stop_thresh = obj->task->task->slobil_stop_error_threshold;
  obj->task->task->slobil_stop_error_threshold = 0;
  execute_0(arg1, obj);
  data* d;
  assign_boolean(&d, is_error(-1, obj->task->task) > 0 ? true : false);
  obj->task->task->slobil_stop_error_threshold = stop_thresh;

  ret_ans(obj, d);
  is_error(0, obj->task->task);

}


void
op_call (arg a, object* obj)
{
  #op=call@
  #length=1@
  ##CHECK_ARGS~$;
  _op_call(a,obj,obj,1);
}

void
op_ignore_errors (arg a, object* obj)
{
  #op=ignore-errors@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Instruction@
  ##GETARG~$;

  int stop_thresh = obj->task->task->slobil_stop_error_threshold;
  obj->task->task->slobil_stop_error_threshold = 0;
  execute_0(arg1, obj);
  obj->task->task->slobil_stop_error_threshold = stop_thresh;
}

void
op_version (arg a, object* obj)
{
  data* d;
  uint32_t* u32version = slobil_u8_to_u32(PACKAGE_VERSION,
                                       strlen(PACKAGE_VERSION));
  assign_str(&d, u32version, 0);

  ret_ans(obj, d);
  
}

void
op_filter (arg a, object* obj)
{
  #op=filter@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Object@
  ##GETARG~$;

  #num=2@
  #type=Operation@
  ##GETARG~$;

  object* r = (object*) arg1->data;
  object* result = new_object(obj, r->hash_size, obj->task);
  arg a1;
  a1.length = 3;
  a1.free_data = malloc(sizeof(int)*a1.length);
  for (int i = 0; i < a1.length; i++)
    a1.free_data[i] = 0;

  a1.arg_array = malloc(sizeof(data*)*a1.length);
  a1.arg_array[0] = arg2;
  a1.arg_array[1] = NULL;
  a1.arg_array[2] = NULL;
  
  for (int i = 0; i < r->hash_size; i++)
    {
      content* c = r->objects[i];
      if (c == NULL)
        continue;

      if (is_init_content(c))
        continue;

      c = tail(c);
      while (c != NULL)
        {
          if (c->value != NULL)
            {
              a1.arg_array[1] = c->value;
              data* key;
              assign_slot(&key, c->name, c->key);
              a1.arg_array[2] = key;
              compute(arg2, obj, a1);
              data* d = lookup(obj, &obj->task->task->slobil_slot_ans, 0);
              if ((d != NULL) && (d->type == Boolean) &&
                  *((bool*) d->data))
                {
                  set(result, copy_data(c->value), c->name, 0);
                }
              free_data(key);
            }
          c = c->right;
        }
    }

  data* d;
  assign_object(&d, result, false, obj->task);
  ret_ans(obj, d);
}

void
op_please (arg a, object* obj)
{
  #op=please@

  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Instruction@
  ##GETARG~$;

  #num=2@
  #type=Instruction@
  ##GETARG~$;

  execute_0(arg1, obj);

  if (is_error(-1, obj->task->task))
    {
      is_error(0, obj->task->task);
      execute_0(arg2, obj);
    }
}

void
op_mod (arg a, object* obj)
{

  #op=mod@

  #length=2@
  ##CHECK_ARGS~$;
  
  #num=1@
  #type=`Integer'@
  ##GETARG~$;

  #num=2@
  #type=`Integer'@
  ##GETARG~$;

  data* d;
  mpz_t res;
  mpz_init(res);
  mpz_fdiv_r(res, *((mpz_t*) arg1->data),
             *((mpz_t*) arg2->data));
  assign_int(&d, res);

  ret_ans(obj,d);
}

void
op_op (arg a, object* obj)
{
  #op=op@

  #length=1@
  ##CHECK_ARGS~$;
    
  #num=1@
  #type=Instruction@
  ##GETARG~$;

  op_wrapper* new_op = malloc(sizeof(op_wrapper));
  new_op->n_arg = a.length-2;
  new_op->instr = copy_data(arg1);
  new_op->args = malloc(sizeof(data*)*new_op->n_arg);
  for (int i=2; i < a.length; i++)
    {
      #num=i@
      #type=Slot@
      ##GETARG~$;

      new_op->args[i-2] = copy_data(argi);
    }

  data* d = malloc(sizeof(data));
  d->data = new_op;
  d->type = Operation;
  ret_ans(obj, d);
}

void
op_use (arg a, object* obj)
{
  #op=use@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=String@
  ##GETARG~$;

  char* str1 = slobil_u32_to_u8((uint32_t*) arg1->data,
                             u32_strlen((uint32_t*) arg1->data));


  char* home = getenv("HOME");
  char* fname = malloc(sizeof(char)*(strlen(home)+
                                     strlen(str1)+
                                     strlen(".dslobs/")+
                                     strlen("/.dslob")+1));
  sprintf(fname, "%s/.dslobs/%s.dslob", home, str1);
  gzFile f = gzopen(fname, "r");
  if (f == NULL)
    {
      do_error("File cannot be opened.",
               obj->task->task);
      free(fname);
      return;
    }

  free(str1);
  read_outer(f, obj);
  gzclose(f);
  free(fname);
}

static void
incr (data* d, mpz_t* shift)
{
  mpz_add(*((mpz_t*) d->data),
          *((mpz_t*) d->data),
          *shift);
}

void
op_incr (arg a, object* obj)
{
  #op=incr@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=`(Integer|Real)'@
  ##GETARG~$;

  if (arg1->type == Integer)
    {

      if (a.length >= 3)
        {
          #num=2@
          #type=Integer@
          ##GETARG~$;
          incr(arg1, (mpz_t*) arg2->data);
        }
      else
        {
          mpz_t m;
          mpz_init_set_si(m, 1);
          incr(arg1, &m);
        }
    }
  else
    {
      double inc;
      if (a.length >= 3)
        {
          #num=2@
          #type=`(Real|Integer)'@
          ##GETARG~$;


          if (arg2->type == Integer)
            {
              inc = mpz_get_d(*((mpz_t*) arg2->data));
            }
          else
            {
              inc = *((double*) arg2->data);
            }
        }
      else
        {
          inc = 1;
        }
      *((double*) arg1->data) += inc;
    }
}

void
op_rehash (arg a, object* obj)
{
  #op=rehash@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Object@
  ##GETARG~$;

  rehash((object*) arg1->data);
  
}

void
op_clock (arg a, object* obj)
{
  #op=clock@
  #length=0@
  ##CHECK_ARGS~$;

  struct timespec spec;
  int time_since_epoch;

  clock_gettime(CLOCK_REALTIME, &spec);
  time_since_epoch = spec.tv_sec;
  
  mpz_t z;
  mpz_init_set_si(z, time_since_epoch);
  mpz_mul_si(z, z, 1000);
  mpz_add_ui(z, z, floor(spec.tv_nsec / 1000000.0));

  data* d;

  assign_int(&d, z);
  mpz_clear(z);
  ret_ans(obj, d);  
}

void
op_make_time (arg a, object* obj)
{
  #op=make-time@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Integer@
  ##GETARG~$;

  mpz_t z;
  mpz_init_set(z, *((mpz_t*) arg1->data));
  mpz_fdiv_q_ui(z, z, 1000);
  time_t t = mpz_get_si(z);
  mpz_clear(z);
  struct tm* loc = localtime(&t);

  object* r = new_object(obj, SLOBIL_HASH_SIZE, obj->task);
  data* d;


  mpz_init_set_si(z, loc->tm_sec);
  assign_int(&d, z);
  mpz_clear(z);
  set(r, d, "second", 0);

  mpz_init_set_si(z, loc->tm_min);
  assign_int(&d, z);
  mpz_clear(z);
  set(r, d, "minute", 0);
  
  mpz_init_set_si(z, loc->tm_hour);
  assign_int(&d, z);
  mpz_clear(z);
  set(r, d, "hour", 0);
  
  mpz_init_set_si(z, loc->tm_mday);
  assign_int(&d, z);
  mpz_clear(z);
  set(r, d, "day", 0);
  
  mpz_init_set_si(z, loc->tm_mon);
  assign_int(&d, z);
  mpz_clear(z);
  set(r, d, "month", 0);

  mpz_init_set_si(z, loc->tm_year);
  assign_int(&d, z);
  mpz_clear(z);
  set(r, d, "year", 0);

  mpz_init_set_si(z,loc->tm_wday);
  assign_int(&d, z);
  mpz_clear(z);
  set(r, d, "day-of-week", 0);

  assign_object(&d, r, false, obj->task);
  ret_ans(obj, d);
  
}

void
op_make_clock (arg a, object* obj)
{
  #op=make-clock@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Object@
  ##GETARG~$;

  struct tm time;

  object* r = (object*) arg1->data;
  data* d;

  slot sl_ms;
  sl_ms.name = "milliseconds";
  sl_ms.key = hash_str("milliseconds");
  d = get(r, &sl_ms, 0);
  if (d == NULL || (d->type != Integer))
    {
      do_error("No Integer data at /milliseconds.", obj->task->task);
      return;
    }

  mpz_t* z_ms;
  z_ms = (mpz_t*) d->data;
  time_t ms = mpz_get_si(*z_ms);

  slot sl_sec;
  sl_sec.name = "seconds";
  sl_sec.key = hash_str("seconds");
  
  d = get(r, &sl_sec, 0);
  if (d == NULL || (d->type != Integer))
    {
      do_error("No Integer data at /seconds.", obj->task->task);
      return;
    }

  time.tm_sec = mpz_get_si(*((mpz_t*) d->data));

  slot sl_minute;
  sl_minute.name = "minute";
  sl_minute.key = hash_str("minute");
  
  d = get(r, &sl_minute, 0);
  if (d == NULL || (d->type != Integer))
    {
      do_error("No Integer data at /minute.", obj->task->task);
      return;
    }

  time.tm_min = mpz_get_si(*((mpz_t*) d->data));

  slot sl_hour;
  sl_hour.name = "hours";
  sl_hour.key = hash_str("hour");
  
  d = get(r, &sl_hour, 0);
  if (d == NULL || (d->type != Integer))
    {
      do_error("No Integer data at /hour.", obj->task->task);
      return;
    }

  time.tm_hour = mpz_get_si(*((mpz_t*) d->data));

  slot sl_day;
  sl_day.name = "day";
  sl_day.key = hash_str("day");
  
  d = get(r, &sl_day, 0);
  if (d == NULL || (d->type != Integer))
    {
      do_error("No Integer data at /day.", obj->task->task);
      return;
    }

  time.tm_mday = mpz_get_si(*((mpz_t*) d->data));

  slot sl_month;
  sl_month.name = "month";
  sl_month.key = hash_str("month");
  
  d = get(r, &sl_month, 0);
  if (d == NULL || (d->type != Integer))
    {
      do_error("No Integer data at /month.", obj->task->task);
      return;
    }

  time.tm_mon = mpz_get_si(*((mpz_t*) d->data)) - 1;
  
  slot sl_year;
  sl_year.name = "year";
  sl_year.key = hash_str("year");

  d = get(r, &sl_year, 0);
  if (d == NULL || (d->type != Integer))
    {
      do_error("No Integer data at /year.", obj->task->task);
      return;
    }

  time.tm_year = mpz_get_si(*((mpz_t*) d->data)) - 1900;

  time_t time_sec;
  time_sec = mktime(&time);

  time_sec = 1000*time_sec + ms;

  mpz_t z;
  mpz_init_set_si(z, time_sec);
  assign_int(&d, z);
  ret_ans(obj,d);
}

       

void
op_task (arg a, object* obj)
{
  #op=task@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Slot@
  ##GETARG~$;

  #num=2@
  #type=Instruction@
  ##GETARG~$;

  object* init_state = NULL;
  if (a.length >= 4)
    {
      #num=3@
      #type=Object@
      ##GETARG~$;
      init_state = (object*) arg3->data;
    }

  task* t = malloc(sizeof(task));
  t->task = new_task(t);
  if (init_state == NULL)
    {
      t->state = new_object(t->task->current_parse_object,
                              SLOBIL_HASH_SIZE,
                              t);
    }
  else
    {
      t->state = copy_object(init_state);
    }
  t->state->up = t->task->current_parse_object;
  t->state->task = t;
  t->task->current_parse_object = t->state;

  t->code = copy_instruction((instruction*) arg2->data);
  t->queued_instruction = new_object(NULL, SLOBIL_HASH_SIZE, t);
  
  t->pid = -1;
  t->thread = NULL;

  data* d = new_data();
  d->type = Task;
  d->data = t;

  set(obj, d, ((slot*) arg1->data)->name, 1);
  
}

void
op_run_task (arg a, object* obj)
{
  #op=run-task@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Task@
  ##GETARG~$;

  if (((task*) arg1->data)->thread != NULL)
    {
      do_error("Task already running.", obj->task->task);
      return;
    }

  pthread_t* pt = malloc(sizeof(pthread_t));
  int ret = pthread_create(pt, NULL, run_task_thread, arg1);
  if (ret)
    {
      do_error("Thread creation failed.", obj->task->task);
    }
  else
    {
      ((task*) arg1->data)->thread = pt;
    }
}

void
op_queue (arg a, object* obj)
{
  #op=queue@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Slot@
  ##GETARG~$;

  #num=2@
  #checktype=false@
  ##GETARG~$;
  #checktype=true@

  data* d = copy_data(arg2);

  task* t;
  if (a.length >= 4)
    {
      #num=3@
      #type=Task@
      ##GETARG~$;
      t = (task*) arg3->data;
    }
  else
    {
      t = obj->task;
    }


  pthread_mutex_lock(&t->lock);
  
  if (t->queued_instruction == NULL)
    {
      do_error("Task has no queue.  Data cannot be queued.", obj->task->task);
    }
  else
    {
      set(t->queued_instruction, d,
          ((slot*) arg1->data)->name, 0);
    }
  pthread_mutex_unlock(&t->lock);

}

void
op_accept (arg a, object* obj)
{
  #op=accept@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Slot@
  ##GETARG~$;

  if (obj->task->queued_instruction==NULL)
    {
      /* We are in the main task. */
      do_error("Use <accept-or> from the main task.",
               obj->task->task);
      return;
    }
  
  task* t;
  if (a.length >= 3)
    {
      #num=2@
      #type=Task@
      ##GETARG~$;
      t = (task*) arg2->data;
    }
  else
    {
      t = obj->task;
    }

  pthread_mutex_lock(&t->lock);
  if (t->queued_instruction == NULL)
    {
      do_error("Task has no queue, cannot accept data.",
               obj->task->task);
      pthread_mutex_unlock(&t->lock);
      return;
    }
  pthread_mutex_unlock(&t->lock);
    
  data* d = NULL;
  while (d == NULL)
    {
      pthread_mutex_lock(&t->lock);
      d = get(t->queued_instruction,
              ((slot*) arg1->data),
              0);
      if (d==NULL)
        {
          pthread_mutex_unlock(&t->lock);
        }
    }

  del(t->queued_instruction, ((slot*) arg1->data),
      0, false);  
  ret_ans(obj, d);
  pthread_mutex_unlock(&t->lock);
}

void
op_select (arg a, object* obj)
{
  #op=select@
  #length=1@
  ##CHECK_ARGS~$;

  int sz = ceil((a.length-1)/2);
  data* hashes[sz];
  data* actions[sz];

  int hash_idx = 0;
  int action_idx = 0;

  for (int i=1; i < a.length; i=i+2)
    {
      #num=i@
      #type=Slot@
      ##GETARG~$;

      hashes[hash_idx] = argi;

      hash_idx++;
      int i1 = i+1;
      #num=i1@
      #type=Instruction@
      ##GETARG~$;
      actions[action_idx] = argi1;
      action_idx++;
    }

  if (hash_idx != action_idx)
    {
      do_error("Number of locations to select should match the number of actions to take on matching.",
               obj->task->task);
      return;
    }

  data* d = NULL;
  task* t = obj->task;

  pthread_mutex_lock(&t->lock);
  if (t->queued_instruction == NULL)
    {
      do_error("Task has no queue, cannot accept data.",
               obj->task->task);
      pthread_mutex_unlock(&t->lock);
      return;
    }
  pthread_mutex_unlock(&t->lock);

  int idx;
  while (d==NULL)
    {
      pthread_mutex_lock(&t->lock);
      for (int i=0; i < hash_idx; i++)
        {
          d = get(t->queued_instruction,
                  ((slot*) hashes[i]->data),
                  0);
          if (d != NULL)
            {
              idx = i;
              d = copy_data(d);
              ret_ans(obj,d);
              del(t->queued_instruction,
                  ((slot*) hashes[idx]->data),
                  1, false);

              break;
            }
        }
      if (d == NULL)
        {
          pthread_mutex_unlock(&t->lock);
        }
    }

  pthread_mutex_unlock(&t->lock);
  execute_0(actions[idx], obj);
  
}

void
op_accept_or (arg a, object* obj)
{
  #op=accept-or@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Slot@
  ##GETARG~$;

  #num=2@
  #type=Instruction@
  ##GETARG~$;

  task* t;
  if (a.length >= 4)
    {
      #num=3@
      #type=Task@
      ##GETARG~$;
      t = (task*) arg3->data;
    }
  else
    {
      t = obj->task;
    }

  pthread_mutex_lock(&t->lock);
  data* d = get(t->queued_instruction,
                ((slot*) arg1->data),
                0);
  pthread_mutex_unlock(&t->lock);

  if (d==NULL)
    {
      execute_0(arg2, obj);
    }
  else
    {
      pthread_mutex_lock(&t->lock);
      del(t->queued_instruction, ((slot*) arg1->data),
          0, false);
      ret_ans(obj,d);
      pthread_mutex_unlock(&t->lock);
    }
}

void
op_rand (arg a, object* obj)
{
  #op=rand@

  if (a.length >= 2)
    {
      #num=1@
      #type=Integer@
      ##GETARG~$;
      srand(mpz_get_si(*((mpz_t*) arg1->data)));
    }

  double r = ((double) rand()) / ((double) RAND_MAX);
  data* d;
  assign_real(&d, r);
  ret_ans(obj,d);
}

void op_floor (arg a, object* obj)
{
  #op=floor@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Real@
  ##GETARG~$;

  int r = (int) floor(*((double*) arg1->data));
  mpz_t res;
  mpz_init(res);
  mpz_set_si(res, r);
  data* d;
  assign_int(&d, res);
  ret_ans(obj,d);
}

void op_ceiling (arg a, object* obj)
{
  #op=ceiling@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
  #type=Real@
  ##GETARG~$;

  int r = (int) ceil(*((double*) arg1->data));
  mpz_t res;
  mpz_init(res);
  mpz_set_si(res, r);
  data* d;
  assign_int(&d, res);
  ret_ans(obj,d);
}

void
op_interpreter (arg a, object* obj)
{
  #op=interpreter@
  #length=0@
  ##CHECK_ARGS~$;

  data* d1 = NULL;
  data* d2 = NULL;

  for (int i=1; i < a.length; i = i + 2)
    {
      d1 = a.arg_array[i];
      if (d1->type != Slot)
        {
          do_error("Expected a slot.", obj->task->task);
          return;
        }

      d2 = resolve(a.arg_array[i+1], obj);
      d2 = copy_data(d2);
      set(obj->task->task->slobil_options,
          d2, ((slot*) d1->data)->name, 1);
    }
}

void
op_build (arg a, object* obj)
{
  #op=build@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
  #type=String@
  ##GETARG~$;

  #num=2@
  #type=Object@
  ##GETARG~$;
  

  char* loc = slobil_u32_to_u8((uint32_t*) arg1->data,
                              u32_strlen((uint32_t*) arg1->data));


  char* home = getenv("HOME");
  char* fname = malloc(sizeof(char)*(strlen(home)+
                                     strlen(loc)+
                                     strlen(".dslobs/")+
                                     strlen("/.dslob")+1));
  sprintf(fname, "%s/.dslobs/%s.dslob", home, loc);

  data* d = copy_data(arg2);
  save_outer((object*) d->data, fname);
  
  free(loc);
  free(fname);
  free_data(d);
  
}

void
op_set_help (arg a, object* obj)
{
  #op=set-help@
  #length=2@
  ##CHECK_ARGS~$;

  #num=1@
	#type=`(Instruction|Operation)'@
  ##GETARG~$;

  #num=2@
  #type=String@
  ##GETARG~$;

  data* instr;
  if (arg1->type == Operation)
    {
      if (((op_wrapper*) arg1->data)->instr == NULL)
        {
          do_error("Base operations cannot have help text.",
                   obj->task->task);
          return;
        }
      instr = ((op_wrapper*) arg1->data)->instr;
    }
  else
    {
      instr = arg1;
    }
  char* help_text = slobil_u32_to_u8((uint32_t*) arg2->data,
                                     u32_strlen((uint32_t*) arg2->data));

  ((instruction*) instr->data)->help = help_text;

}

void
op_help (arg a, object* obj)
{
  #op=help@
  #length=1@
  ##CHECK_ARGS~$;

  #num=1@
	#type=`(Operation|Instruction)'@
  ##GETARG~$;

  data* instr;
  if (arg1->type == Operation)
    {
      instr = ((op_wrapper*) arg1->data)->instr;
    }
  else
    {
      instr = arg1;
    }

  if (((instruction*) instr->data)->help != NULL)
    {
      printf("\n%s\n", ((instruction*) instr->data)->help);
    }
}


void
add_basic_ops (object* obj)
{
  data* d;

  /* Object operations */

  /** Creation **/

  assign_op(&d, op_object, NULL, NULL, 0);
  set(obj,d,"object",1);

  assign_op(&d, op_list, NULL, NULL, 0);
  set(obj,d,"list",1);

  assign_op(&d, op_range, NULL, NULL, 0);
  set(obj,d,"range",1);

  assign_op(&d, op_new, NULL, NULL, 0);
  set(obj, d, "new", 1);
  
  /** Insert, Move, and Remove **/
  
  assign_op(&d, op_set, NULL, NULL, 0);
  set(obj, d, "set",1);

  assign_op(&d, op_move, NULL, NULL, 0);
  set(obj,d,"move",1);

  assign_op(&d, op_delete, NULL, NULL, 0);
  set(obj,d,"delete",1);

  /** Access Data **/

  assign_op(&d, op_get, NULL, NULL, 0);
  set(obj,d,"get",1);

  assign_op(&d, op_exist, NULL, NULL, 0);
  set(obj,d,"exist",1);

  assign_op(&d, op_import, NULL, NULL, 0);
  set(obj,d,"import",1);

  assign_op(&d, op_filter, NULL, NULL, 0);
  set(obj,d,"filter",1);

  /** Apply Operations **/

  assign_op(&d, op_do, NULL, NULL, 0);
  set(obj,d,"do",1);
  
  assign_op(&d, op_collapse, NULL, NULL, 0);
  set(obj,d,"collapse",1);

  /** Execute Code in Object **/

  assign_op(&d, op_in, NULL, NULL, 0);
  set(obj,d,"in",1);

  assign_op(&d, op_up, NULL, NULL, 0);
  set(obj,d,"up",1);

  /** Test if object **/
  
  assign_op(&d, op_is_object, NULL, NULL, 0);
  set(obj,d,"is-object",1);


  /** Technical **/
  
  assign_op(&d, op_rehash, NULL, NULL, 0);
  set(obj,d,"rehash",1);


  /* Numeric operations */

  /** Arithmetic **/
  
  assign_op(&d, op_add, NULL, NULL, 0);
  set(obj,d,"add",1);

  assign_op(&d, op_mul, NULL, NULL, 0);
  set(obj,d,"mul",1);

  assign_op(&d, op_sub, NULL, NULL, 0);
  set(obj,d,"sub",1);

  assign_op(&d, op_div, NULL, NULL, 0);
  set(obj,d,"div",1);

  assign_op(&d, op_mod, NULL, NULL, 0);
  set(obj,d,"mod",1);

  assign_op(&d, op_incr, NULL, NULL, 0);
  set(obj,d,"incr",1);

  /** Comparison **/


  assign_op(&d, op_gt, NULL, NULL, 0);
  set(obj,d,"gt",1);

  assign_op(&d, op_lt, NULL, NULL, 0);
  set(obj,d,"lt",1);

  assign_op(&d, op_eq, NULL, NULL, 0);
  set(obj,d,"eq",1);

  assign_op(&d, op_lt_eq, NULL, NULL, 0);
  set(obj,d,"lt-eq",1);

  assign_op(&d, op_gt_eq, NULL, NULL, 0);
  set(obj,d,"gt-eq",1);

  /** Conversion **/

  assign_op(&d, op_to_number, NULL, NULL, 0);
  set(obj,d,"to-number",1);

  assign_op(&d, op_to_real, NULL, NULL, 0);
  set(obj,d,"to-real",1);

  /** Test if type **/

  assign_op(&d, op_is_integer, NULL, NULL, 0);
  set(obj,d,"is-integer",1);

  assign_op(&d, op_is_real, NULL, NULL, 0);
  set(obj,d,"is-real",1);

  /** Common math operations **/
  assign_op(&d, op_log, NULL, NULL, 0);
  set(obj,d,"log",1);

  assign_op(&d, op_exp, NULL, NULL, 0);
  set(obj,d,"exp",1);

  assign_op(&d, op_power, NULL, NULL, 0);
  set(obj,d,"power",1);

  assign_op(&d, op_floor, NULL, NULL, 0);
  set(obj,d, "floor",1);

  assign_op(&d, op_ceiling, NULL, NULL, 0);
  set(obj,d, "ceiling",1);

  /* Boolean operations */

  assign_op(&d, op_and, NULL, NULL, 0);
  set(obj,d,"and",1);

  assign_op(&d, op_or, NULL, NULL, 0);
  set(obj,d,"or",1);

  assign_op(&d, op_not, NULL, NULL, 0);
  set(obj,d,"not",1);

  assign_op(&d, op_is_boolean, NULL, NULL, 0);
  set(obj,d,"is-boolean",1);

  /* Instruction operations */

  assign_op(&d, op_code, NULL, NULL, 0);
  set(obj,d,"code",1);

  assign_op(&d, op_call, NULL, NULL, 0);
  set(obj,d,"call",1);

  assign_op(&d, op_op, NULL, NULL, 0);
  set(obj,d,"op",1);

  assign_op(&d, op_is_instruction, NULL, NULL, 0);
  set(obj,d,"is-instruction",1);

  assign_op(&d, op_is_operation, NULL, NULL, 0);
  set(obj,d,"is-operation",1);

  assign_op(&d, op_set_help, NULL, NULL, 0);
  set(obj,d,"set-help",1);

  assign_op(&d, op_help, NULL, NULL, 0);
  set(obj,d,"help",1);
  
  /* String operations */

  /** Access, search, and modify **/

  assign_op(&d, op_substring, NULL, NULL, 0);
  set(obj,d,"substring",1);

  assign_op(&d, op_match, NULL, NULL, 0);
  set(obj,d,"match",1);

  assign_op(&d, op_replace, NULL, NULL, 0);
  set(obj,d,"replace",1);

  /** String Properties **/
  
  assign_op(&d, op_length, NULL, NULL, 0);
  set(obj,d,"length",1);

  /** String Comparison **/
  
  assign_op(&d, op_string_eq, NULL, NULL, 0);
  set(obj,d,"string-eq",1);

  assign_op(&d, op_string_gt, NULL, NULL, 0);
  set(obj,d,"string-gt",1);
  
  assign_op(&d, op_string_lt, NULL, NULL, 0);
  set(obj,d,"string-lt",1);

  assign_op(&d, op_char_eq, NULL, NULL, 0);
  set(obj,d,"char-eq",1);

  /** Combine Strings **/

  assign_op(&d, op_combine, NULL, NULL, 0);
  set(obj,d,"combine",1);

  /** Convert to Strings **/

  assign_op(&d, op_to_string, NULL, NULL, 0);
  set(obj,d,"to-string",1);

  /** Test if string **/

  assign_op(&d, op_is_string, NULL, NULL, 0);
  set(obj,d,"is-string",1);

  /** Strings from User Input **/

  assign_op(&d, op_input, NULL, NULL, 0);
  set(obj,d,"input",1);


  /* Environment operations */

  /** Modify the /ans slot **/

  assign_op(&d, op_answer, NULL, NULL, 0);
  set(obj,d,"answer",1);

  assign_op(&d, op_sit, NULL, NULL, 0);
  set(obj,d,"sit",1);

  /** Exit SLOBIL **/
  
  assign_op(&d, op_exit, NULL, NULL, 0);
  set(obj,d,"exit",1);

  /** Print output **/
  
  assign_op(&d, op_print, NULL, NULL, 0);
  set(obj,d,"print",1);

  /** Input and output files and state **/

  assign_op(&d, op_save, NULL, NULL, 0);
  set(obj,d,"save",1);

  assign_op(&d, op_load, NULL, NULL, 0);
  set(obj,d,"load",1);

  assign_op(&d, op_output_code, NULL, NULL, 0);
  set(obj,d,"output-code",1);

  assign_op(&d, op_clear_code, NULL, NULL, 0);
  set(obj,d,"clear-code",1);

  assign_op(&d, op_source, NULL, NULL, 0);
  set(obj,d,"source",1);

  /** Error handling **/

  assign_op(&d, op_error, NULL, NULL, 0);
  set(obj,d,"error",1);

  assign_op(&d, op_ignore_errors, NULL, NULL, 0);
  set(obj,d,"ignore-errors",1);


  assign_op(&d, op_is_error, NULL, NULL, 0);
  set(obj,d,"is-error",1);

  /** Version **/

  assign_op(&d, op_version, NULL, NULL, 0);
  set(obj,d,"version",1);

  /* Slot operations */

  /** Operations on "list" slots **/
  assign_op(&d, op_next, NULL, NULL, 0);
  set(obj,d,"next",1);

  assign_op(&d, op_previous, NULL, NULL, 0);
  set(obj,d,"previous",1);

  assign_op(&d, op_last, NULL, NULL, 0);
  set(obj,d,"last",1);

  /** Convert to slot **/

  assign_op(&d, op_to_slot, NULL, NULL, 0);
  set(obj,d,"to-slot",1);

  /** Slot Comparison **/

  assign_op(&d, op_slot_eq, NULL, NULL, 0);
  set(obj,d,"slot-eq",1);

  /** Test if slot **/

  assign_op(&d, op_is_slot, NULL, NULL, 0);
  set(obj,d,"is-slot",1);

  /* File operations */

  assign_op(&d, op_is_file, NULL, NULL, 0);
  set(obj,d,"is-file",1);

  assign_op(&d, op_open_file, NULL, NULL, 0);
  set(obj,d,"open-file",1);

  assign_op(&d, op_read_char, NULL, NULL, 0);
  set(obj,d,"read-char",1);

  assign_op(&d, op_read, NULL, NULL, 0);
  set(obj,d,"read",1);

  assign_op(&d, op_close, NULL, NULL, 0);
  set(obj,d,"close",1);

  assign_op(&d, op_read_line, NULL, NULL, 0);
  set(obj,d,"read-line",1);
  
  assign_op(&d, op_write, NULL, NULL, 0);
  set(obj,d,"write",1);

  assign_op(&d, op_write_string, NULL, NULL, 0);
  set(obj,d,"write-string",1);

  /* System operations */


  /** Shell operations */


  assign_op(&d, op_shell, NULL, NULL, 0);
  set(obj,d,"shell",1);

  assign_op(&d, op_change_dir, NULL, NULL, 0);
  set(obj,d,"change-dir",1);

  assign_op(&d, op_current_dir, NULL, NULL, 0);
  set(obj,d,"current-dir",1);



  /** Time operations **/
  
  assign_op(&d, op_clock, NULL, NULL, 0);
  set(obj,d,"clock",1);

  assign_op(&d, op_make_time, NULL, NULL, 0);
  set(obj,d,"make-time",1);

  assign_op(&d, op_make_clock, NULL, NULL, 0);
  set(obj,d,"make-clock",1);

  /** Random operations **/

  assign_op(&d, op_rand, NULL, NULL, 0);
  set(obj, d, "rand", 1);

  /* Nothing operations */

  assign_op(&d, op_is_nothing, NULL, NULL, 0);
  set(obj,d,"is-nothing",1);


  /* Task operations */

  assign_op(&d, op_task, NULL, NULL, 0);
  set(obj,d,"task",1);

  assign_op(&d, op_run_task, NULL, NULL, 0);
  set(obj,d,"run-task",1);

  assign_op(&d, op_queue, NULL, NULL, 0);
  set(obj,d,"queue",1);

  assign_op(&d, op_accept, NULL, NULL, 0);
  set(obj,d,"accept",1);

  assign_op(&d, op_select, NULL, NULL, 0);
  set(obj,d,"select",1);

  assign_op(&d, op_accept_or, NULL, NULL, 0);
  set(obj,d,"accept-or",1);

  /* Control flow operations */

  assign_op(&d, op_if, NULL, NULL, 0);
  set(obj,d,"if",1);

  assign_op(&d, op_while, NULL, NULL, 0);
  set(obj,d,"while",1);
  
  assign_op(&d, op_repeat, NULL, NULL, 0);
  set(obj,d,"repeat",1);
  
  assign_op(&d, op_please, NULL, NULL, 0);
  set(obj,d,"please",1);


  /* Interpreter options */

  assign_op(&d, op_interpreter, NULL, NULL, 0);
  set(obj, d, "interpreter", 1);

  /* Package build */

  assign_op(&d, op_build, NULL, NULL, 0);
  set(obj, d, "build", 1);

  assign_op(&d, op_use, NULL, NULL, 0);
  set(obj,d,"use",1);

  assign_op(&d, op_link, NULL, NULL, 0);
  set(obj,d,"link",1);

  
}
  
